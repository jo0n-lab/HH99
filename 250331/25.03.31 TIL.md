* **문제 링크**: https://www.acmicpc.net/problem/1929
* **난이도**: 솔직히 쉽다. 감사합니다~~ 
* **유형**: #math

이런 유형의 문제는.. 솔직히 감사합니다~~
근데 반대로 못 풀면 바보되는 거다.

여기서 핵심은 **"에라토스테네스의 체"** 에 대해 알고 있고, 구현이 가능하냐는 거다.
에라토스테네스라는 수학자가 만든 소수를 걸러내는 방법론인데, 걸러낸다는 점에서 체라고 하나보다.
이 정도는 바로 짜본다~

```
#include<iostream>
using namespace std;

//1~100 까지, 해당 위치의 수가 소수인지
int prime[102];

int main(){
	fill(prime,prime+102,1);

	//소수의 정의에 의거
	prime[1]=0;

	//설명 참고
	for(int i=2;i*i<=100;i++){
		if(prime[i]==0) continue;
		for(int j=i*i;j<=100;j+=i)
			prime[j]=0;
	}

}
```

위의 알고리즘에서 흥미로운 점은,

1. `for(int i=2;i*i<=100;i++)` 
2. `for(int j=i*i;j<=100;j+=i)`

이렇게 제곱 혹은 루트의 형태로 루프를 도는 것인데, 연속된 자연수 수열을 관찰하면 금방 이해할 수 있다.
**소수로 정의되는 수는, 본인 이외의 소인수가 본인 이전에 등장할 수 없기 때문이다.** 
즉, 새로운 소수를 k 라 했을시, 1 ~ (k-1) 에서는 k의 소인수가 등장하지 않고, k 이후에 유의미한(방문하지 않은) 수이면서 k 를 소인수로 가지는 첫번째 수는 $k^2$ 이기 때문이다.


* **문제풀이**: 거의 동일하므로 생략한다.
* **테스트케이스**: 
```
1 3
```

코드 제출했을 때, 80% 쯤에서 틀렸는데,, 위의 테스트케이스와 동일한 케이스였다.
즉, 1인 경우에 생각하지 못한 점이었는데, 여기서 이를 방지하기 위해서는 항상 2가지를 생각하며 습관으로 들여야 겠다.

1. 정의에 충실하기
2. 경계값 테스트케이스 확인하기

1번은 소수의 정의를 만족하지 못했기 때문이라 생각한다. 정의는 중요하다.
2번은 정말,,,, 기본이다. 모든 문제를 풀 경우, 반드시 검증해야 하는 중요한 케이스라 생각한다.

**TIL 을 기록하는 김에, 정말 중요한 습관은 README 에 기록하고 매번 체크리스트를 작성하여 습관으로 만들어야겠다.**


* 막간일기: 요즘 운전면허 따는데, 퇴근하고 7시쯤 학원가면 9시쯤에 집에 돌아온다.. 피곤하다 ㅠㅠ. 빨리 따야지~~ 저녁은 충무김밥+구운닭을 먹었다. 살찔 거 같다 ㅠㅠ
