# 25.04.01 TIL

### 오늘의 문제
---

* **문제 링크**: https://www.acmicpc.net/problem/14495
* **난이도**: 음.. 이건 더 쉬웠나.. 아무래도 추가 문제를 더 풀 필요는 있어보인다.
* **유형**: #math

해당 문제에서 뭔가 얻어갈 만 했던 거는,, 주어진 입력(?) 정도 였던거 같다.
![[image.png|314x143]]

주어진 자연수의 범위가 $116 \text{ 이하의 자연수}$ 인데, 뭔가 이상하다는 느낌을 받는다.
눈치가 빠르다면,, 뭔가 자료형에 제한을 걸어둔 것이 아닐까.. 유추해볼 수 있다.

피보나치 및 비스무리한 수열의 경우 $f(n)=f(n-p)+f(n-q)$ 꼴의 경우인 수열인데, 대강 계산해봐도 거의 두배가 되니 지수함수 형태로 발산한다는 것을 알 수 있다. (아마 미분하면 상당히 비슷할 꼴의 형태일 것)
즉, `int` 형은 택도 없고, 아마 `long long` 에 대한 제한이지 않을까 싶었다

여튼 그래서 나는 애초에 `int num[122]` 로 두고, 테케를 추가적으로 돌려봤다.
역시나 117 에서 자료형이 터진다.
![[image-2.png|527x91]]

### 추가문제
---
오늘은 추가 문제에 대해 다뤄본다.
어제 오늘 #math 인 거 같으니,, 비슷한 문제를 풀어 봤다

* **문제 링크**: https://www.acmicpc.net/problem/6064
* **난이도**: 어려운 문제는 고르지 않았다. 하지만 배워갈 것이 충분히 있다
* **유형**: #math

해당 문제는 수학적으로는 매우 간단한 문제다. 쉽게 **최대공약수** 및 **최소공배수**를 사용해야겠구나 떠올릴 수 있다.
근데 이걸 코드로 구현하는 것은 또 다른 문제다.
구현의 흐름은 다음과 같다.

1. 최대공약수 알고리즘을 구현한다
2. 1을 사용해서 최소공배수 알고리즘을 구현한다

즉, 최대공약수 알고리즘을 구현하면 최소공배수는 따라오는 구현이다.
그럼,, 최대공약수를 어떻게 구한다..?

이건,, 솔직히 그냥 머리로 깡구현은 불가능한다고 본다. 걍 외우는게 맞다

* **유클리드 호제법**: 자연수 A와 B의 최대공약수는, A를 B로 나눈 나머지를 r이라 할 때, B와 R의 최대공약수와 같다.

이걸 그냥 구현하면 된다. 참고로 최대공약수는 GCD, 최소공배수는 LCD 라고 불린다.

```
int getGCD(int a,int b){
	if(b==0) return a;
	return getGCD(b,a%b);
}
```

최대공약수 구현 뿐 아니라,, 문제에서도 배워갈 게 있다.
역시나,, 경계값 테스트케이스.
그리고, 특이하게 **시간초과**가 발생했는데 이거는 문제의 조건을 보고 알고리즘을 최적화시켜야 되는 케이스다.

![[image-3.png|352x103]]
![[image-4.png]]

M와 N 이 40000 이하인데,, 최소공배수를 생각해보면 $40000^2$ 최악의 케이스에 대해 대비해야한다.
(정확히는 40000 이하의 소수 중, 제일 큰 서로 다른 소수 M과 N)

**시간초과? ==> 무조건 발생한다.**

사실 알고리즘 문제 풀면서, 항상 더 개선할(?) 수 있는 코드지만 그냥.. 귀찮아서 넘어가는 케이스가 많다. 
그런데, 시간 복잡도가 대충 계산하더라도 조건 초과이면, 반드시 최적화 계산을 하자!! 

그래서 오늘의 습관은!

* **주어진 시간 제한에서 시간초과 발생할 거 같으면, 반드시 최적화 해라!**